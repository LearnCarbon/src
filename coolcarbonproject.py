# -*- coding: utf-8 -*-
"""coolCarbonProject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1240EVUCbOa2lGMWg_0Ri7fPD3_TVPpJE

**Prepare Data**
"""

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import csv

from pandas.core.indexing import check_bool_indexer

df= pd.read_csv(r"C:\Users\ppou\source\repos\AEC_Hackathon2021\Data\Data-Set-Material-Categories.csv")

type_local = df['Building Type'].values
#type = np.where(type == 'Commercial', 0, type)
#type = np.where(type == 'Residential', 1, type)
location = df['Location'].values
footprint = df['Foot print (m2)'].values
tot_area = df['GFA (m2)'].values
floors = df['Floor Count'].values
buld_life = df['Life Time (Years)'].values
co2 = df['TC02 (Normalized at 50 years)'].values
material = df['Building_Construction_Type']

FData = []

for i in range(len(type_local)):
    input = type_local[i], location[i], footprint[i], tot_area[i], floors[i],buld_life[i],co2[i],material[i]
    FData.append(input)

dframe = pd.DataFrame(FData)  
#print(dframe)

#Droping the empty rows
clearedDf = dframe.dropna()

clearedDf = clearedDf.rename(columns={0 : 'Type', 1: 'Location', 2 : 'Footprint', 3 : 'Tot_area', 4 : 'Floors', 5 : 'Build_life', 6 : 'CO2', 7 : 'Building_Construction_Type'})

#Saving it to the csv file 
#clearedDf.to_csv('clearedData.csv',index=False)

clearedDf.info()
clearedDf.head()

clearedDf.Type = pd.Categorical(clearedDf.Type)
clearedDf['Type_B'] = clearedDf.Type.cat.codes

clearedDf.Location = pd.Categorical(clearedDf.Location)
clearedDf['Location_B'] = clearedDf.Location.cat.codes

clearedDf.Footprint = pd.Categorical(clearedDf.Footprint)
clearedDf['Footprint_B'] = clearedDf.Footprint.cat.codes

clearedDf.Tot_area = pd.Categorical(clearedDf.Tot_area)
clearedDf['Tot_area_B'] = clearedDf.Tot_area.cat.codes

clearedDf.Floors = pd.Categorical(clearedDf.Floors)
clearedDf['Floors_B'] = clearedDf.Floors.cat.codes

clearedDf.Building_Construction_Type = pd.Categorical(clearedDf.Building_Construction_Type)
clearedDf['Building_Construction_Type'] = clearedDf.Building_Construction_Type.cat.codes

pd.set_option('display.max_columns', None)
print(clearedDf.info())
print(clearedDf.head())

Footprint_B = clearedDf['Footprint_B'].values
Tot_area_B = clearedDf['Tot_area_B'].values
CO2 = clearedDf['CO2'].values

print(np.min(Footprint_B))
print(np.max(Footprint_B))

print("min ", min(Footprint_B))
print("max ", max(Footprint_B))

# We want to convert integers into floats based on the categories of FOOTPRINT_B, TOT_AREA_B, FLOORS_B
#                     -----0-----   -----1----  ------2----- etc.
footprint_bounds_cat = [18581, 46451, 2324, 4645, 46452, 92903, 4646, 9290, 466, 929, 9291, 18580, 0, 93, 930, 2323, 94, 465, 92903, 180000]
tot_area_bounds_cat = [1, 1000 , 1001 , 5001, 10001, 25000, 100001, 200000, 200001, 500000, 25001, 50000, 5001, 10000,  50001, 100000, 500001, 1000000, 1000001, 2000000]
floor_bounds_cat = [1, 6, 15, 25, 7, 14, 25, 50]


def pick_value(column_feature, array_bounds, column_carbon):
  # print("Double of categories: ", (len(array_bounds)/2))
  # print("Number of categories: ", int(len(array_bounds)/2))
  test_array = np.empty(len(column_feature))
  for i in range(int(len(array_bounds)/2)):
    print("category ", i)
    lower_bound = float(array_bounds[i*2])
    upper_bound = float(array_bounds[(i*2) +1])
    # print("lower bound", lower_bound)
    # print("upper bound", upper_bound)
    # create the array with carbon
    array_carbon = []
    for j in range(len(column_feature)):
      # print("problem index", j)
      # print(column_feature[j])
      if(column_feature[j] == i):
        array_carbon.append(column_carbon[j])

    
    # print("number of entries: ", len(array_carbon))
    CO_lower_bound = min(array_carbon)
    CO_upper_bound = max(array_carbon)

    # print("CO lower bound", CO_lower_bound)
    # print("CO upper bound", CO_upper_bound)

    for k in range(len(column_feature)):
      if(column_feature[k] == i):
        #print("before map", column_feature[k])
        # translate the carbon value to the range of the feature
        #column_feature[k] = float(lower_bound +((upper_bound - lower_bound) / (CO_upper_bound - CO_lower_bound))*(column_carbon[k] - CO_lower_bound))
        test_array[k] = round(float(lower_bound +((upper_bound - lower_bound) / (CO_upper_bound - CO_lower_bound))*(column_carbon[k] - CO_lower_bound)), 2)
        # print("co2 ", column_carbon[k])
        # print("after map", test_array[k])
    
  return test_array

column_c_np = np.asarray(CO2)

# Area
column_f_np = np.asarray(Footprint_B)
test_area_mapped_fo = pick_value(column_f_np, footprint_bounds_cat, column_c_np)
clearedDf['clear_Area'] = test_area_mapped_fo

# FLOORS
column_floors = np.asarray(clearedDf['Floors_B'].values)
test_area_mapped_fl = pick_value(column_floors, floor_bounds_cat, column_c_np)
clearedDf['clear_floors'] = test_area_mapped_fl

pd.set_option('display.max_columns', None)
print(clearedDf.info())
print(clearedDf.head())

clearedDf.to_csv('FinalData.csv',index=False)